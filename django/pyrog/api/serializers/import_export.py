"""Serializer for the full mapping.

These serializers add their child nested representations. Parent relation will be
deduced from the hierarchy. Some relations (to owners and columns) use an exported
primary key to make reference from other branch in the hierarchy.

    Usage example:

    from pyrog.api.serializers.import_export import SourceSerializer

On import, the Credential attribute should contain both login and password
and the Owner schema attribute is ignored if specified and always autogenerated.
If the source database connection fails, the mapping is not recorded.
"""

from typing import Mapping

from rest_framework import serializers

from common.adapters.fhir_api import fhir_api
from pagai.database_explorer.database_explorer import DatabaseExplorer
from pyrog.models import (
    Attribute,
    Column,
    Condition,
    Credential,
    Filter,
    Input,
    InputGroup,
    Join,
    Owner,
    Resource,
    Source,
)
from river.common.database_connection.db_connection import DBConnection


class _ColumnField(serializers.PrimaryKeyRelatedField):
    """PKRelatedField with default deserialization overriden.

    The default deserialization looks for an object with given id (the ``data``) in DB.
    But here the id refers to another object, that lives elsewhere in the submitted data
    hierarchy (accessible from ``self.root.initial_data``).
    """

    queryset = Column.objects.all()

    def to_internal_value(self, data):
        """Find the actual representation in the submitted data, or raise."""

        for owner in self.root.initial_data["credential"]["owners"]:
            for column in owner["columns"]:
                if column["id"] == data:
                    return data
        raise serializers.ValidationError("No associated Column.")


class _OwnerField(serializers.PrimaryKeyRelatedField):
    """PKRelatedField with default deserialization overriden.

    Cf ``_ColumField``.
    """

    queryset = Owner.objects.all()

    def to_internal_value(self, data):
        """Find the actual representation in the submitted data, or raise."""

        for owner in self.root.initial_data["credential"]["owners"]:
            if owner["id"] == data:
                return data
        raise serializers.ValidationError("No associated Owner.")


class MappingJoinSerializer(serializers.ModelSerializer):
    columns = _ColumnField(many=True)

    class Meta:
        model = Join
        fields = ["columns"]


class MappingColumnSerializer(serializers.ModelSerializer):
    joins = MappingJoinSerializer(many=True, required=False, default=[])

    class Meta:
        model = Column
        fields = ["id", "table", "column", "joins"]
        extra_kwargs = {"id": {"read_only": False}}  # Put `id` in validated data


class MappingOwnerSerializer(serializers.ModelSerializer):
    columns = MappingColumnSerializer(many=True, required=False, default=[])

    class Meta:
        model = Owner
        fields = ["id", "name", "columns"]
        extra_kwargs = {"id": {"read_only": False}}  # Put `id` in validated data

    def to_internal_value(self, data):
        credential = self.root.initial_data["credential"]
        try:
            db_connection = DBConnection(credential)
            explorer = DatabaseExplorer(db_connection)
            name = data["name"]
            data["schema"] = explorer.get_owner_schema(name)
        except Exception as e:
            raise serializers.ValidationError(e)
        return super().to_internal_value(data)


class MappingPartialCredentialSerializer(serializers.ModelSerializer):
    owners = MappingOwnerSerializer(many=True, required=False, default=[])

    class Meta:
        model = Credential
        fields = ["host", "port", "database", "model", "owners"]


class MappingCredentialSerializer(MappingPartialCredentialSerializer):
    class Meta(MappingPartialCredentialSerializer.Meta):
        fields = MappingPartialCredentialSerializer.Meta.fields + ["login", "password"]

    def validate(self, data):
        try:
            db_connection = DBConnection(data).engine.connect()
            db_connection.close()
        except Exception as e:
            raise serializers.ValidationError(e)
        return super().validate(data)


class MappingInputSerializer(serializers.ModelSerializer):
    column = _ColumnField(allow_null=True)

    class Meta:
        model = Input
        fields = ["script", "concept_map_id", "static_value", "column"]


class MappingConditionSerializer(serializers.ModelSerializer):
    column = _ColumnField()

    class Meta:
        model = Condition
        fields = [
            "action",
            "column",
            "value",
            "relation",
        ]


class MappingInputGroupSerializer(serializers.ModelSerializer):
    inputs = MappingInputSerializer(many=True, required=False, default=[])
    conditions = MappingConditionSerializer(many=True, required=False, default=[])

    class Meta:
        model = InputGroup
        fields = ["id", "merging_script", "inputs", "conditions"]


class MappingAttributeSerializer(serializers.ModelSerializer):
    input_groups = MappingInputGroupSerializer(many=True, required=False, default=[])

    class Meta:
        model = Attribute
        fields = ["path", "slice_name", "definition_id", "input_groups"]


class MappingFilterSerializer(serializers.ModelSerializer):
    sql_column = _ColumnField()

    class Meta:
        model = Filter
        fields = ["relation", "value", "sql_column"]


class MappingResourceSerializer(serializers.ModelSerializer):
    primary_key_owner = _OwnerField()
    attributes = MappingAttributeSerializer(many=True, required=False, default=[])
    filters = MappingFilterSerializer(many=True, required=False, default=[])
    logical_reference = serializers.CharField()

    class Meta:
        model = Resource
        fields = [
            "id",
            "label",
            "primary_key_table",
            "primary_key_column",
            "definition_id",
            "logical_reference",
            "primary_key_owner",
            "attributes",
            "filters",
        ]

    def validate(self, data):
        request = self.context.get("request")
        auth_token = request.session.get("oidc_access_token") if request else None
        try:
            data["definition"] = fhir_api.retrieve("StructureDefinition", data["definition_id"], auth_token)
        except Exception as e:
            raise serializers.ValidationError({"definition": [str(e)]})
        return super().validate(data)


class MappingSerializer(serializers.ModelSerializer):
    resources = MappingResourceSerializer(many=True, required=False, default=[])
    credential = MappingCredentialSerializer()

    class Meta:
        model = Source
        exclude = ["users"]

    def create(self, validated_data):
        """Create Source and related models from the validated representation.

        The same pattern is applied hierarchically:
            * Pop data of interest from validated data,
            * Create models,
            * Apply to child representations.

        Owners and columns are created first and kept in registries. When crossing later
        references to owner or column objects, the associated models will be found with
        those registries.
        """

        resources_data = validated_data.pop("resources")
        credential_data = validated_data.pop("credential")
        owners_data = credential_data.pop("owners")

        source = Source.objects.create(**{**validated_data, "id": None})
        credential = Credential.objects.create(source=source, **credential_data)

        # Registries to track owner and column instances by their exported ids
        owner_by_id: Mapping[str, Owner] = {}
        column_by_id: Mapping[str, Column] = {}

        # First hierarchy
        for owner_data in owners_data:
            columns_data = owner_data.pop("columns")

            owner = Owner.objects.create(
                credential=credential,
                **{**owner_data, "id": None},  # Ignore provided `id` field
            )

            owner_by_id[owner_data["id"]] = owner

            # Intermediate list (ordered) to track Join instances
            joins = []

            for column_data in columns_data:
                joins_data = column_data.pop("joins")

                column = Column.objects.create(
                    owner=owner,
                    **{**column_data, "id": None},  # Ignore provided `id` field
                )

                column_by_id[column_data["id"]] = column

                for _ in joins_data:
                    joins.append(Join.objects.create(column=column))

                # Put back the joins data for the second pass
                column_data["joins"] = joins_data

            # Second pass to set the references to joins on columns,
            # now that all columns have been created.
            for column_data in columns_data:
                joins_data = column_data.pop("joins")
                for join_data in joins_data:
                    # Order is important
                    join = joins.pop(0)
                    for column_data in join_data["columns"]:
                        column = column_by_id[column_data]
                        column.join = join
                        column.save(update_fields=["join", "updated_at"])

        # Main hierarchy
        for resource_data in resources_data:
            filters_data = resource_data.pop("filters")
            attributes_data = resource_data.pop("attributes")
            owner_data = resource_data.pop("primary_key_owner")

            owner = owner_by_id[owner_data]
            resource = Resource.objects.create(primary_key_owner=owner, source=source, **{**resource_data, "id": None})

            for filter_data in filters_data:
                column_data = filter_data.pop("sql_column")

                column = column_by_id[column_data]
                Filter.objects.create(resource=resource, sql_column=column, **filter_data)

            for attribute_data in attributes_data:
                input_groups_data = attribute_data.pop("input_groups")

                attribute = Attribute.objects.create(resource=resource, **attribute_data)

                for input_group_data in input_groups_data:
                    inputs_data = input_group_data.pop("inputs")
                    conditions_data = input_group_data.pop("conditions")

                    input_group = InputGroup.objects.create(attribute=attribute, **{**input_group_data, "id": None})

                    for input_data in inputs_data:
                        static_value = input_data.pop("static_value")
                        column_id = input_data.pop("column")

                        if static_value:
                            Input.objects.create(
                                input_group=input_group,
                                static_value=static_value,
                                **input_data,
                            )
                        else:
                            column = column_by_id[column_id]
                            Input.objects.create(
                                input_group=input_group,
                                column=column,
                                **input_data,
                            )

                    for condition_data in conditions_data:
                        column_data = condition_data.pop("column")

                        column = column_by_id[column_data]
                        Condition.objects.create(input_group=input_group, column=column, **condition_data)

        return source


class MappingWithPartialCredentialSerializer(MappingSerializer):
    credential = MappingPartialCredentialSerializer()
